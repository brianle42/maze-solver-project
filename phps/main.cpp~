/*******************************************************************************
 *
 * main.cpp - Source File
 *
 * Description	:	Moonlight Company
 *			Maze Solver Project
 *			Percept Handling and Planning Subsystem (PHPS)
 *			by Moonlight Company, 
 *			for the semesters Fall 2015 & Spring 2016 
 *			for the courses EE 493-494 Engineering Design I & II
 *
 * Modified	: 15.05.2016 by Doga Yucalan ( yucalan.doga@metu.edu.tr  )
 * Created	: 13.04.2016 by Utku Norman  ( norman.utku@metu.edu.tr  )
 *
 * People	:	Doga Yucalan ( yucalan.doga@metu.edu.tr )
 *			Utku Norman  ( norman.utku@metu.edu.tr  )
 * 
 * Style	:
 *
 *  http://geosoft.no/development/cppstyle.html#Include Files
 *
 * Associated code snippet sources :
 *
 *  http://opencv-code.com/tutorials/detecting-simple-shapes-in-an-image/
 *  https://github.com/bsdnoobz/opencv-code/blob/master/shape-detect.cpp
 *  http://stackoverflow.com/questions/20492152/
 *	how-to-find-no-of-inner-holes-using-cvfindcontours-and-hierarchy
 *  http://docs.opencv.org/2.4/doc/tutorials/
 *	imgproc/shapedescriptors/find_contours/find_contours.html
 *
 ******************************************************************************/

// Command Line I/O related headers
#include <cstddef>  			// std::nullptr
#include <iostream> 			// std::cout, std::cin, std::endl
#include <iomanip>  			// std::setw
#include <cstdlib>  			// EXIT_SUCCESS, EXIT_FAILURE

#include <opencv2/opencv.hpp> 		// Image Processing (OpenCV) header

// Handler descriptions for the parts of PHPS
#include "include/CCHandler.h"		// Camera Capture		(CC)
#include "include/IPHandler.h"		// Image Preprocessor		(IP)
#include "include/PSMHandler.h"		// Platform State Mapper	(PSM)
#include "include/LMHandler.h"		// Labyrinth Mapper		(LM)
#include "include/RPHandler.h"		// Route Planner		(RP)
#include "include/DDHandler.h"		// Direction Decider		(DD)
#include "include/CUHandler.h"		// Control Unit			(CU)
#include "include/CHandler.h"		// Communication		(C)
#include "include/Visualizer.h"		// Visualization header
#include "include/Auxiliaries.h"	// Other auxiliary methods header

#include "include/Packages.h"	// Other auxiliary methods header

#define METHOD_FATAL	-1
#define METHOD_SUCCESS	0
#define METHOD_FAILURE	1

// Initializer debugs modes
const bool IPInitDebugMode	= false	;

// Handler debugs modes
const bool CCHandlerDebugMode	= false	;
const bool IPHandlerDebugMode	= false	;
const bool PSMHandlerDebugMode	= false	;
const bool LMHandlerDebugMode	= false	;
const bool RPHandlerDebugMode	= false	;
const bool DDHandlerDebugMode	= false	;
const bool CUHandlerDebugMode	= false	;
const bool CHandlerDebugMode	= false	;

// For the printStates
// Printer debugs modes
const bool CCPrintDebugMode	= false	;
const bool IPPrintDebugMode	= false	;
const bool PSMPrintDebugMode	= false	;
const bool LMPrintDebugMode	= true	;
const bool RPPrintDebugMode	= false	;
const bool DDPrintDebugMode	= false	;
const bool CUPrintDebugMode	= false	;
const bool CPrintDebugMode	= false	;

// Display debugs modes
const bool CCDisplayDebugMode	= true	;
const bool IPDisplayDebugMode	= false	;
const bool PSMDisplayDebugMode	= false	;
const bool LMDisplayDebugMode	= true	;
const bool RPDisplayDebugMode	= false	;
const bool DDDisplayDebugMode	= false	;
const bool CUDisplayDebugMode	= false	;
const bool CDisplayDebugMode	= false	;

// Declare the main handlers
CCHandler	mainCCHandler	;
IPHandler	mainIPHandler	;
PSMHandler	mainPSMHandler	;
LMHandler	mainLMHandler	;
RPHandler	mainRPHandler	;
DDHandler	mainDDHandler	;
CUHandler	mainCUHandler	;
CHandler	mainCHandler	;

// Declare the packages to be passed in between the handlers
CCPacket	rawImageData	;
IPPacket	ppResults	;
PSMPacket	platformState	;
LMPacket	labyrinthState	;
RPPacket 	desiredPathData ;  //RPPacket	plan		;
DDPacket	errorInfo	;
CUPacket	commandInfo	;
CHPacket 	senseDataInfo 	;

//std::string	command		;
//std::string	senseData	;

// Construct horizontalImageData
CCPacket horizontalImageData	;
CCPacket topImageData	;
CCPacket bottomImageData	;

const std::string horizontalImagePath 	( "./images/mid.jpg" ) ; // by default
const std::string topImagePath		( "./images/max.jpg" ) ; // by default
const std::string bottomImagePath	( "./images/min.jpg" ) ; // by default

std::string configFilename( "./out_camera_data.xml" ) ;

cv::FileStorage fs( configFilename , cv::FileStorage::READ );

void calibrate( cv::Mat& distortfulImage );

void loadHorizontalImage( void );

void loadTopImage( void );

void loadBottomImage( void );

bool prepareCC( int argcData, char** argvData );

// Initialize the main IP
void prepareIP( );

int initAll( int argc , char** argv , bool debugMode ) ;

void waitMain( bool stepByStepMode );

bool stepByStepMode;
int stepNo;

/*******************************************************************************
 *
 * main
 *
 ******************************************************************************/

int main( int argc , char** argv )
{

	initAll( argc , argv , true );


	/*********************
	 * Setup Loop
	 *********************/

	while( true )	// Labyrinth & Platform State Estimation Loop
	{
		break ;
	} 


	std::cout << "Begin the main loop. "		;
	std::cout << std::endl				;

	/*********************
	 * Maze Solving Loop
	 *********************/

	while( true )	// Maze Solving Loop
	{

		/*************************
		 * step tracking 
		 ************************/

		stepNo++ ;

		if( stepNo % 10 == 0 )
		{

			std::cout << "||||| Step no: " << stepNo		;
			std::cout << std::endl					;

		}

		/*************************
		 * main body of the loop  
		 ************************/

		// Run the main Camera Capture Handler
		rawImageData	= mainCCHandler.handle( CCHandlerDebugMode ) ;	

		// Run the Image Preprocessor Handler
		ppResults	= mainIPHandler.handle( rawImageData , IPHandlerDebugMode ) ;

		// Run the main Platform State Mapper Handler
		platformState	= mainPSMHandler.handle( ppResults.borderPoints , ppResults.calibrationData , PSMHandlerDebugMode ) ;

		// Run the main Labyrinth Mapper Handler 	: hangi yyyy
		labyrinthState 	= mainLMHandler.handle( ppResults.borderPoints , ppResults.mazeData , LMHandlerDebugMode ) ;

		// Run the main Route Planner Handler 		: o yolda ne taraf CW - CCW - IN - OUT
		desiredPathData = mainRPHandler.handle( labyrinthState.ballLocationData , RPHandlerDebugMode  ) ;

		// Run the main Direction Decider Handler	: ~ next robot state estimator - ne kadar yukarı ya da aşağı
		errorInfo	= mainDDHandler.handle(	platformState , labyrinthState.ballPositionAngle , desiredPathData , DDHandlerDebugMode) ; 

		// Run the main Controller Unit Handler		: WsWSWSWSSSSSWWWWWW <- T/B
		commandInfo	= mainCUHandler.handle( errorInfo , platformState , senseDataInfo , CUHandlerDebugMode ) ;
		//
		// P:
		// Kp=1 		-> W
		// Kp=10 		-> WWWWWWWWWWWWWW
		// PI
		// Kp=1 	k2=1	-> W
		// k1=10 	k2=1	-> WWWWWWWWWW

		// Run the main Communication Handler		: T/B
		//WWWWWWWWWWWWWW
		senseDataInfo	= mainCHandler.handle( commandInfo , CHandlerDebugMode ) ;

		/*************************
		 * state prints 
		 ************************/

		// Print the states for monitoring
		mainCCHandler .printState( CCPrintDebugMode	,	CCDisplayDebugMode	)	;

		mainIPHandler .printState( IPPrintDebugMode	,	IPDisplayDebugMode	)	;

		mainPSMHandler.printState( PSMPrintDebugMode	,	PSMDisplayDebugMode	)	;

		mainLMHandler .printState( LMPrintDebugMode	,	LMDisplayDebugMode	)	;

		mainRPHandler .printState( RPPrintDebugMode	,	RPDisplayDebugMode	)	;

		mainDDHandler .printState( DDPrintDebugMode	,	DDDisplayDebugMode	)	;

		mainCUHandler .printState( CUPrintDebugMode	,	CUDisplayDebugMode	)	;

		mainCHandler  .printState( CPrintDebugMode	,	CDisplayDebugMode	)	;

		/*************************
		 * Interstep Processes
		 ************************/

		// Pause
		waitMain( stepByStepMode ) ;
		
	}

	return 0;
}

/*******************************************************************************
 *
 * Helper Methods
 *
 ******************************************************************************/

void waitMain( bool stepByStepMode )
{
	int keyCode	;

	if( stepByStepMode )
	{

		keyCode = cv::waitKey( 0 ) ;

		if( keyCode == 27 )  			// 27 = ascii('ESC')
		{

			std::exit( EXIT_SUCCESS );

		}

	}
	else
	{
	
		keyCode = cv::waitKey( 25 )	;	// Wait for a key for 25 ms

		if( keyCode == 80 || keyCode == 112 ) 	// 80 <-> 'P' , 112 <-> 'p'
		{

			keyCode = cv::waitKey( 100000 )	; // Wait long

		}
		
		if( keyCode == 27 )  			// 27 = ascii('ESC')
		{

			std::exit( EXIT_SUCCESS );

		}

	}
	
}

/*******************************************************************************
 *
 * Initialization Methods
 *
 ******************************************************************************/
int initAll( int argc , char** argv , bool debugMode = true )
{

	// Declare and initialize the local variables
	stepNo = 0 					;	// Step counter for the main loop
	stepByStepMode = false ;

	if( debugMode )
	{

		std::cout << "Begin the preparations. "		;
		std::cout << std::endl				;
	
	}
	
	/*********************
	 * Initialization
	 *********************/

	loadHorizontalImage( )				;

	if( debugMode )
	{

		std::cout << "Horizontal image initialized. "	;
		std::cout << std::endl				;

	}

	loadTopImage( )					;

	if( debugMode )
	{

		std::cout << "Top image initialized. "		;
		std::cout << std::endl				;

	}

	loadBottomImage( )				;

	if( debugMode )
	{

		std::cout << "Bottom image initialized. "	;
		std::cout << std::endl				;

	}

	stepByStepMode = prepareCC( argc, argv )	;

	if( debugMode )
	{

		std::cout << "CC ready. "			;
		std::cout << std::endl				;

	}

	if( stepByStepMode )
	{

		std::cout << "stepByStepMode mode active: " 	;	
		std::cout << "Single image processing only. "	;
		std::cout << std::endl ;

	}
	else
	{

		std::cout << "stepByStepMode mode passive: " 	;
		std::cout << "Automatic capture is activated. " ;
		std::cout << std::endl ;


	}
	
	prepareIP( )					;

	std::cout << "IP ready. "			;
	std::cout << std::endl				;

}



void calibrate( cv::Mat& distortfulImage )
{
    
    cv::Mat intrinsics , distortion;

    fs[ "camera_matrix" ]               >> intrinsics   ;

    fs[ "distortion_coefficients" ]     >> distortion   ;

    cv::Mat undistortedImage;

    cv::undistort(distortfulImage, undistortedImage, intrinsics, distortion);
 
    distortfulImage = undistortedImage.clone(); // now, undistorted

    return; 

}

void loadHorizontalImage( void )
{

	horizontalImageData.image = cv::imread( 
		horizontalImagePath.c_str( ) , 1 ) ;
	
	// Check if image exists
	if ( !horizontalImageData.image.data )
	{

		std::cerr << "Unable to load horizontalImageData image!" ;
		std::cerr << std::endl 	; 

		std::cerr << "at path: " << horizontalImagePath.c_str( ) ,
		std::cerr << std::endl 	; 

		std::exit( EXIT_FAILURE );

	}

	//showImage("hori-uncal", horizontalImageData.image );
	//cv::waitKey( 0 );

	//calibrate( horizontalImageData.image );

	//showImage("hori-cal", horizontalImageData.image );
	//cv::waitKey( 0 );

}

void loadTopImage( void )
{

	topImageData.image = cv::imread( topImagePath.c_str( ) , 1 ) ;
	
	// Check if image exists
	if ( !topImageData.image.data )
	{

		std::cerr << "Unable to load topImageData image!" ;
		std::cerr << std::endl 	; 

		std::cerr << "at path: " << topImagePath.c_str( ) ,
		std::cerr << std::endl 	; 

		std::exit( EXIT_FAILURE );

	}

	//calibrate( topImageData.image );

}

void loadBottomImage( void )
{

	bottomImageData.image = cv::imread( bottomImagePath.c_str( ) , 1 ) ;
	
	// Check if image exists
	if ( !bottomImageData.image.data )
	{

		std::cerr << "Unable to load bottomImageData image!" ;
		std::cerr << std::endl 	; 

		std::cerr << "at path: " << bottomImagePath.c_str( ) ,
		std::cerr << std::endl 	; 

		std::exit( EXIT_FAILURE );

	}

	//calibrate( bottomImageData.image );

}

bool prepareCC( int argcData, char** argvData )
{
	cv::Mat	image ;
	bool singleShotMode = false ;
	bool successFlag ;

	// Check for the correct number for arguments
	if ( argcData >= 2 )
	{

		// Load the image addressed in the second argument
		image = cv::imread( argvData[ 1 ] , 1 );

		// Check for validity of the image
		if ( !image.data )  // If successfully loaded
		{
			std::cerr <<"prepareCC: No image data" ;
			std::cerr << std::endl ;
			std::exit( EXIT_FAILURE );
		}

		singleShotMode = true;
		successFlag = mainCCHandler.initialize( image ) ;


	}
	else if( argcData == 1 )
	{

		singleShotMode = false;
		successFlag = mainCCHandler.initialize( ) ;

	}
	else
	{

		std::cerr << "CCHandler: undefined usage. "		;
		std::cerr << std::endl ;

		std::cerr << "Usage-1: './mazeSolver'"			; 
		std::cerr << "for the main image stream from camera ";
		std::cerr << "and default horizontal image"	;
		std::cerr << std::endl ;

		std::cerr << "Usage-2: './mazeSolver <image-path>'" ;
		std::cerr << " to process one single image present in the <image-path>";
		std::cerr << "and default horizontal image"	;
		std::cerr << std::endl ;

		/*
		std::cerr << "Usage-3: './mazeSolver <image-path>' <horizontal-image-path>" 	;
		std::cerr << " to process one single image present in the <image-path>"			;
		std::cerr << "and the image in <horizontal-image-path> as the horizontal image"	;
		std::cerr << std::endl ;
		*/

		std::exit( EXIT_FAILURE );
	}

	if( !successFlag )
	{

		std::cerr << "mainCCHandler initialization failed."	;
		std::cerr << std::endl	;

		std::exit( EXIT_FAILURE );

	}

	return singleShotMode;

}

// Initialize the main IP
void prepareIP( )
{

	if ( !mainIPHandler.initialize( horizontalImageData , 'H', IPInitDebugMode ) ||
	     !mainIPHandler.initialize( topImageData , 'T', IPInitDebugMode ) ||  
	     !mainIPHandler.initialize( bottomImageData , 'B', IPInitDebugMode ))
	{

		std::cerr << "mainIPHandler initialization failed."	;
		std::cerr << std::endl	;

		//std::exit( EXIT_FAILURE );

	}

}
